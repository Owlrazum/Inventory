Non-sphere states:
    Idle,
    Walking,
    GroundJump,
    Gliding


bug related to Input maybe related to the execution order



    _belowSlopeAngle = Vector2.Angle(_belowHitsStorage[i].normal, transform.up);
    Vector3 crossBelowSlopeAngle = Vector3.Cross(transform.up, _belowHitsStorage[i].normal);
    if (crossBelowSlopeAngle.z < 0)
    {
        _belowSlopeAngle = -_belowSlopeAngle;
    }

// if the character is jumping onto a (1-way) platform but not high enough, we do nothing
    if (
        _prevIsCollidingToTheDown
        && (smallestDistance < _worldColliderSize.y / 2)
        && (
            _oneWayPlatformMask.MMContains(_standingOnObject.layer)
            ||
            (_movingOneWayPlatformMask.MMContains(_standingOnObject.layer) && (_externalDisplacement.y > 0))
        )
    )
    {
        _isCollidingToTheDown = false;
        return;
    }

// we check if the character is standing on a moving platform
    _movingPlatformTest = _belowHitsStorage[smallestDistanceIndex].collider.gameObject.MMGetComponentNoAlloc<MMPathMovement>();
    if (_movingPlatformTest != null && State.IsGrounded)
    {
        _movingPlatform = _movingPlatformTest.GetComponent<MMPathMovement>();
    }
    else
    {
        DetachFromMovingPlatform();
    }

// if we were grounded last frame and if this is our first ray, we don't cast against one way platforms
    if (_prevIsCollidingToTheDown && i == 0)
    {
        if (raysDirection == HorizontalDirection.Left)
        {
            sideHitsStorage[i] = MMDebug.RayCast(
                rayOriginPoint,
                -transform.right,
                raycastLength,
                _platformsLayerMask & ~_oneWayPlatformMask & ~_movingOneWayPlatformMask, 
                MMColors.Indigo, 
                _drawRaycastDebugGizmos)
            ;
        }
        else if (raysDirection == HorizontalDirection.Right)
        { 
            sideHitsStorage[i] = MMDebug.RayCast(
                rayOriginPoint, 
                transform.right, 
                raycastLength, 
                _platformsLayerMask & ~_oneWayPlatformMask & ~_movingOneWayPlatformMask, 
                MMColors.Indigo, _drawRaycastDebugGizmos
            );
        }
    }

// if we're in the air, we prevent the character from being pushed back.
    if (!_isCollidingToTheDown && (_externalDisplacement.y != 0) && (!Mathf.Approximately(hitAngle, 90f)))
    {
        _externalDisplacement.x = 0;
    }

    //float rayLength = _isCollidingToTheDown ? _rayOffset : _externalDisplacement.y;
        //rayLength += _worldColliderSize.y / 2;